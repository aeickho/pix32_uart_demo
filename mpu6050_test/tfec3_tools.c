#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <p32xxxx.h>
#include <plib.h>

#include "aeickho-tiny-fecc/tfec3.h"
#include "basic.h"
#include "tools/printf.h"
#include "nrf.h"
#include "delay.h"


#define NDEBUG

#include <assert.h>

int
random ()
{
  srand (ReadCoreTimer ());
  return (rand ());
}


/*                           FRAME (32bytes)
 *  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 *  |      MID      | ...........24 bytes of fragment data...........
 *  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 *  ............................................... | METAD | CRC16 |
 *  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 *
 *  15        METAD (16bits)       0      MID = message ID
 *  +-------+-----------+-----------+       S = size in fragments (1-15)
 *  |   S   |     0     |    FNUM   |    FNUM = fragment number   (0-17)
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   CRC16 = checksum for whole frame
 *
 *  For frames with S <= FNUM, the frame transports recovery data
 *  generated by TFEC3. The purpose of MID is to identify which fragments
 *  belong to the same message. The message size S must also be the same
 *  for all fragments of the same message. The supported message size is
 *  therefore 24 bytes * 15 fragments = 360 bytes. For such large messages
 *  it seems like a good idea to add 20% of redundancy (3 additional
 *  fragments). For smaller messages a fewer number of recovery fragments
 *  can be used.
 */

#define MIN(x,y) ((y)<(x)?(y):(x))

#define WORDS_PER_FRAGMENT   6
#define BYTES_PER_FRAGMENT  (WORDS_PER_FRAGMENT*4)
#define MAX_DATA_FRAGMENTS  15
#define MAX_RECOV_FRAGMENTS  3
#define MAX_MESSAGE_SIZE    (BYTES_PER_FRAGMENT*MAX_DATA_FRAGMENTS)
#define FRAME_BUFF_SIZE     (MAX_DATA_FRAGMENTS+MAX_RECOV_FRAGMENTS)


struct frame
{
  tfec3_u32 mid;
  tfec3_u32 fragmentdata[WORDS_PER_FRAGMENT];
  unsigned short metad;
  unsigned short crc16;
};

#define NUM_DATA_FRAGS(pf)  ((pf)->metad >> 12)
#define FRAGMENT_INDEX(pf)  ((pf)->metad &  63)

uint32_t t[20];

static unsigned
compute_frame_crc (const struct frame *pf)
{
  return crc16 (pf, 4 +		/* message id */
		4 * WORDS_PER_FRAGMENT +	/* fragment data */
		2		/* metad */
    );
}

static void
print_frame (const struct frame *pf)
{
  int j;
  const char *p;
  tfp_printf ("MID=%08X, [", pf->mid);
  p = (const char *) pf->fragmentdata;
  for (j = 0; j < BYTES_PER_FRAGMENT; ++j)
    {
      if (32 <= p[j] && p[j] < 127)
	tfp_printf ("%c", p[j]);
      else
	tfp_printf (".");
    }
  tfp_printf ("], METAD=%04X, CRC16=%04X\n\r", pf->metad, pf->crc16);
}



/* frame buffer for reception and transmission */
static struct frame tx_frame[FRAME_BUFF_SIZE];
static unsigned char tx_valid[FRAME_BUFF_SIZE];
static short send_count = 0;	/* number of frames to send */
static short send_next = 0;	/* next frame to send */



/**
 * message send preparation (fragmenting and framing)
 *
 * The function takes a "message" up to MAX_MESSAGE_SIZE bytes, chops it up
 * into fragments and adds a little redundancy and overwrites the send
 * buffer's frames
 *
 * @param n
 *   Size of message in bytes (1...MAX_MESSAGE_SIZE)
 * @param msg
 *   Pointer to message
 * @param redundancy_percentage
 *   Percentage of redundancy fragments (0...20). For short messages you can
 *   actually use redundancies up to 300. But no more than three redundancy
 *   fragments are added to the frame buffer.
 * @return
 *   the actual percentage of redundancy that has been generated
 */
int
prepare_send_message (int n, const char msg[], int redundancy_percentage)
{
  tfec3_u32 mid;
  unsigned s, k, i, c;
  tfec3_u32 *fragdatas[FRAME_BUFF_SIZE];
  memset (tx_valid, 0, sizeof tx_valid);
  assert (0 < n && n <= MAX_MESSAGE_SIZE);
  mid = rand ();		//0x1729BEEF; /* we should pick a message id at random!!! */
  s = (n + BYTES_PER_FRAGMENT - 1) / BYTES_PER_FRAGMENT;	/* # of user fragments */
  k = MIN (3, (s * redundancy_percentage + 99) / 100);	/* # of redundancy fragments */
  i = 0;
  while (n > 0)
    {
      tx_frame[i].mid = mid;
      tx_frame[i].metad = (s << 12) + i;
      fragdatas[i] = tx_frame[i].fragmentdata;
      c = MIN (BYTES_PER_FRAGMENT, n);	/* chunk of data to copy */
      if (c < BYTES_PER_FRAGMENT)
	memset (fragdatas[i], 0, BYTES_PER_FRAGMENT);
      memcpy (fragdatas[i], msg, c);
      tx_frame[i].crc16 = compute_frame_crc (tx_frame + i);
      tx_valid[i] = 1;
      msg += c;
      n -= c;
      ++i;
    }

  assert (i == s);
  while (i < s + k)
    {
      tx_frame[i].mid = mid;
      tx_frame[i].metad = (s << 12) + i;
      fragdatas[i] = tx_frame[i].fragmentdata;
      ++i;
    }
  tfec3_encode (WORDS_PER_FRAGMENT, s, k, fragdatas);
  for (i = s; i < s + k; ++i)
    {
      tx_frame[i].crc16 = compute_frame_crc (tx_frame + i);
      tx_valid[i] = 1;
    }
  send_count = s + k;		/* number of frames to send */
  send_next = 0;		/* from the start please... */
  return (k * 100 + (s >> 1)) / s;
}

/**
 * Recover lost fragment data of a message
 *
 * Valid received frames from one specific message (all the same message ID)
 * have to be placed at the correct index in the tx_frame buffer and marked
 * as valid via tx_valid. If you received a frame you can check its index via
 * FRAGMENT_INDEX(pointer_to_frame). Check this value and compare it with
 * FRAME_BUFF_SIZE unless you like buffer overflows.
 *
 * @return
 *   the number of data fragments on success (without redundancy),
 *   0 otherwise.
 */
int
recover_received_message (void)
{
  int i, s, k, n;
  tfec3_u32 *fragdatas[FRAME_BUFF_SIZE];
  s = -1;
  n = 0;
  for (i = 0; i < FRAME_BUFF_SIZE; ++i)
    {
      fragdatas[i] = tx_frame[i].fragmentdata;
      if (tx_valid[i])
	{
	  if (s < 0)
	    s = tx_frame[i].metad >> 12;
	  n = 1 + i;
	}
    }
  k = n - s;
  return tfec3_decode (WORDS_PER_FRAGMENT, s, k, tx_valid, fragdatas) ? s : 0;
}


/**
 * extracts fragments from frame buffer into a user-supplied buffer
 *
 * @param howmany
 *   number of fragments to extract and concatenate
 * @param target
 *   pointer to target buffer with at least howmany*BYTES_PER_FRAGMENT
 *   free space.
 */
void
collect_fragments (int howmany, char target[])
{
  int i;
  for (i = 0; i < howmany; ++i)
    {
      memcpy (target, tx_frame[i].fragmentdata, BYTES_PER_FRAGMENT);
      target += BYTES_PER_FRAGMENT;
    }
}

static void
destroy_frame (int whichone)
{
  assert (0 <= whichone && whichone < FRAME_BUFF_SIZE);
  memset (tx_frame + whichone, 0, sizeof (*tx_frame));
  tx_valid[whichone] = 0;
}

void
nrf_send_frames (struct frame *frame, int frames)
{
  tfp_printf ("\r\nframes %d\n\r", frames);

  int i;
  t[0] = ReadCoreTimer ();
  for (i = 0; i < frames - 1; i++)
    {
      t[i + 1] = ReadCoreTimer ();
      nrf_send_frame ((uint8_t *) (frame + i), 0);
      if (i % 4 == 3)
	{
	  delay_ms (5);
	}
    }
  tfp_printf (".,.");

  nrf_send_frame ((uint8_t *) (frame + frames - 1), 1);
  t[i + 2] = ReadCoreTimer ();

  for (i = 0; i < frames; ++i)
    {
      tfp_printf ("%08d ns %08d ns\n\r", (t[i + 1] - t[0]) * 50,
	      (t[i + 1] - t[i]) * 50);
    }


}


int
sendblock (void)
{

  int n, r, i, ret;
  char msg[300];
  static int cnt = 0;

  tfp_sprintf (msg,
	       "Nachricht %d na da will ich mal sehen.........xxxxxxxxxxxxxxxxxxxxxxsadasdasdasdasdasdasdasdadasdasdas.........................................................................................................................................................................................................aaa",
	       cnt++);



  tfp_printf ("Preparing a message for sending... len %d\n\r", strlen (msg));
  n = strlen (msg) + 1;		/* message size including null terminator */
  r = 40;			/* shoot for 20% redundancy */
  r = 150;
  t[0] = ReadCoreTimer ();

  r = prepare_send_message (n, msg, r);
  t[1] = ReadCoreTimer ();

/*  destroy_frame (0);
  destroy_frame (1);
  destroy_frame (2);

*/
  tfp_printf ("time for prepare_send_message %d ns", (t[1] - t[0]) * 50);

  tfp_printf ("number of frames for message = %d\n\r", send_count);
  tfp_printf ("           actual redundancy = %d%%\n\r", r);

  for (i = 0; i < send_count; ++i)
    {
      print_frame (tx_frame + i);
    }

  tfp_printf ("send frames: \n\r");

  t[0] = ReadCoreTimer ();

////////////////////////////////////

// 

//tx_frame->fragmentdata [2]=33;
//(tx_frame+2) ->fragmentdata [2]=33;
//(tx_frame+3) ->fragmentdata [2]=33;

// static struct frame tx_frame[FRAME_BUFF_SIZE];

// void nrf_send_frames (uint8_t  ** frame, int frames)

  tfp_printf ("-> %x \n\r", tx_frame);
  tfp_printf ("-> %x \n\r", tx_frame + 1);
  tfp_printf ("-> %c %c %c \n\r", tx_frame[0], tx_frame[1], tx_frame[2]);
  tfp_printf ("xxxxxxxxxxxxx\n\r");
  delay_ms (1);

  nrf_send_frames (tx_frame, send_count);

// nrf_send_frame (uint8_t * frame, int mode)

/*
  for (i = 0; i < send_count; ++i)
    {
      t[i + 1] = ReadCoreTimer ();
      nrf_send_frame ((uint8_t *) (tx_frame + i), 0);
      if (i % 4 == 0)
	{
	  delay_ms (5);
	}

    }
*/

///***************************

  for (i = 0; i < send_count; ++i)
    {
      print_frame (tx_frame + i);
    }


  return 0;
}


void
test (void)
{
  while (1)
    {
      sendblock ();
      delay_ms (1000);
    }
}
