#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <p32xxxx.h>
#include <plib.h>

#include "aeickho-tiny-fecc/tfec3.h"
#include "basic.h"
#include "tools/printf.h"
#include "nrf24l01p.h"   


#define NDEBUG

#include <assert.h>

int random() {
        srand(ReadCoreTimer());
return (rand());
}


/*                           FRAME (32bytes)
 *  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 *  |      MID      | ...........24 bytes of fragment data...........
 *  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 *  ............................................... | METAD | CRC16 |
 *  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 *
 *  15        METAD (16bits)       0      MID = message ID
 *  +-------+-----------+-----------+       S = size in fragments (1-15)
 *  |   S   |     0     |    FNUM   |    FNUM = fragment number   (0-17)
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   CRC16 = checksum for whole frame
 *
 *  For frames with S <= FNUM, the frame transports recovery data
 *  generated by TFEC3. The purpose of MID is to identify which fragments
 *  belong to the same message. The message size S must also be the same
 *  for all fragments of the same message. The supported message size is
 *  therefore 24 bytes * 15 fragments = 360 bytes. For such large messages
 *  it seems like a good idea to add 20% of redundancy (3 additional
 *  fragments). For smaller messages a fewer number of recovery fragments
 *  can be used.
 */

#define MIN(x,y) ((y)<(x)?(y):(x))

#define WORDS_PER_FRAGMENT   6
#define BYTES_PER_FRAGMENT  (WORDS_PER_FRAGMENT*4)
#define MAX_DATA_FRAGMENTS  15
#define MAX_RECOV_FRAGMENTS  3
#define MAX_MESSAGE_SIZE    (BYTES_PER_FRAGMENT*MAX_DATA_FRAGMENTS)
#define FRAME_BUFF_SIZE     (MAX_DATA_FRAGMENTS+MAX_RECOV_FRAGMENTS)


struct frame {
        tfec3_u32 mid;
        tfec3_u32 fragmentdata[WORDS_PER_FRAGMENT];
        unsigned short metad;
        unsigned short crc16;
};

#define NUM_DATA_FRAGS(pf)  ((pf)->metad >> 12)
#define FRAGMENT_INDEX(pf)  ((pf)->metad &  63)

uint32_t t[10];

static unsigned compute_frame_crc(const struct frame *pf)
{
        return crc16(pf,
                4+                    /* message id */
                4*WORDS_PER_FRAGMENT+ /* fragment data */
                2                     /* metad */
                );
}

static void print_frame(const struct frame *pf)
{
        int j;
        const char *p;
        tfp_printf("MID=%08X, [",pf->mid);
        p = (const char*) pf->fragmentdata;
        for (j=0; j<BYTES_PER_FRAGMENT; ++j) {
                if (32<=p[j] && p[j]<127)
                        tfp_printf("%c",p[j]);
                else
                        tfp_printf(".");
        }
        tfp_printf("], METAD=%04X, CRC16=%04X\n\r",pf->metad,pf->crc16);
}



/* frame buffer for reception and transmission */
static struct frame  tx_frame[FRAME_BUFF_SIZE];
static unsigned char tx_valid[FRAME_BUFF_SIZE];
static short send_count = 0; /* number of frames to send */
static short send_next  = 0; /* next frame to send */



/**
 * message send preparation (fragmenting and framing)
 *
 * The function takes a "message" up to MAX_MESSAGE_SIZE bytes, chops it up
 * into fragments and adds a little redundancy and overwrites the send
 * buffer's frames
 *
 * @param n
 *   Size of message in bytes (1...MAX_MESSAGE_SIZE)
 * @param msg
 *   Pointer to message
 * @param redundancy_percentage
 *   Percentage of redundancy fragments (0...20). For short messages you can
 *   actually use redundancies up to 300. But no more than three redundancy
 *   fragments are added to the frame buffer.
 * @return
 *   the actual percentage of redundancy that has been generated
 */
int prepare_send_message(int n, const char msg[], int redundancy_percentage)
{
        tfec3_u32 mid;
        unsigned s, k, i, c;
        tfec3_u32 *fragdatas[FRAME_BUFF_SIZE];
        memset(tx_valid,0,sizeof tx_valid);
        assert(0<n && n<=MAX_MESSAGE_SIZE);
        mid = rand(); //0x1729BEEF; /* we should pick a message id at random!!! */
        s = (n+BYTES_PER_FRAGMENT-1)/BYTES_PER_FRAGMENT; /* # of user fragments */
        k = MIN(3,(s*redundancy_percentage+99)/100);     /* # of redundancy fragments */
        i = 0;
        while (n>0) {
                tx_frame[i].mid = mid;
                tx_frame[i].metad = (s<<12) + i;
                fragdatas[i] = tx_frame[i].fragmentdata;
                c = MIN(BYTES_PER_FRAGMENT,n); /* chunk of data to copy */
                if (c<BYTES_PER_FRAGMENT)
                        memset(fragdatas[i],0,BYTES_PER_FRAGMENT);
                memcpy(fragdatas[i],msg,c);
                tx_frame[i].crc16 = compute_frame_crc(tx_frame+i);
                tx_valid[i] = 1;
                msg += c;
                n   -= c;
                ++i;
        }

assert(i==s);
        while (i<s+k) {
                tx_frame[i].mid = mid;
                tx_frame[i].metad = (s<<12) + i;
                fragdatas[i] = tx_frame[i].fragmentdata;
                ++i;
        }
        tfec3_encode(WORDS_PER_FRAGMENT,s,k,fragdatas);
        for (i=s; i<s+k; ++i) {
                tx_frame[i].crc16 = compute_frame_crc(tx_frame+i);
                tx_valid[i] = 1;
        }
        send_count = s+k; /* number of frames to send */
        send_next  = 0;   /* from the start please... */
        return (k*100+(s >> 1))/s;
}

/**
 * Recover lost fragment data of a message
 *
 * Valid received frames from one specific message (all the same message ID)
 * have to be placed at the correct index in the tx_frame buffer and marked
 * as valid via tx_valid. If you received a frame you can check its index via
 * FRAGMENT_INDEX(pointer_to_frame). Check this value and compare it with
 * FRAME_BUFF_SIZE unless you like buffer overflows.
 *
 * @return
 *   the number of data fragments on success (without redundancy),
 *   0 otherwise.
 */
int recover_received_message(void)
{
        int i, s, k, n;
        tfec3_u32 *fragdatas[FRAME_BUFF_SIZE];
        s = -1;
        n = 0;
        for (i=0; i<FRAME_BUFF_SIZE; ++i) {
                fragdatas[i] = tx_frame[i].fragmentdata;
                if (tx_valid[i]) {
                        if (s<0) s = tx_frame[i].metad >> 12;
                        n = 1+i;
                }
        }
        k = n - s;
        return tfec3_decode(WORDS_PER_FRAGMENT,s,k,tx_valid,fragdatas) ? s : 0;
}


/**
 * extracts fragments from frame buffer into a user-supplied buffer
 *
 * @param howmany
 *   number of fragments to extract and concatenate
 * @param target
 *   pointer to target buffer with at least howmany*BYTES_PER_FRAGMENT
 *   free space.
 */
void collect_fragments(int howmany, char target[])
{
        int i;
        for (i=0; i<howmany; ++i) {
                memcpy(target,tx_frame[i].fragmentdata,BYTES_PER_FRAGMENT);
                target += BYTES_PER_FRAGMENT;
        }
}

static void destroy_frame(int whichone)
{
        assert(0<=whichone && whichone<FRAME_BUFF_SIZE);
        memset(tx_frame+whichone,0,sizeof(*tx_frame));
        tx_valid[whichone] = 0;
}

int sendblock(void)
{

        int n, r, i;
        const char* msg =
                "Hello World! This is a m"  /* fragment 0 */
                "essage that will be chop"  /* fragment 1 */
                "ped up into multiple pie"  /* fragment 2 */
                "ces. The pieces called f"  /* fragment 3 */
                "ragments are framed and "  /* fragment 4 */
                "checksummed. Let's see h"  /* fragment 5 */
                "ow that goes...";          /* fragment 6 */
        tfp_printf("Preparing a message for sending...\n\r");
        n = strlen(msg)+1; /* message size including null terminator */
        r = 20; /* shoot for 20% redundancy */
        r = prepare_send_message(n,msg,r);
        tfp_printf("number of frames for message = %d\n\r",send_count);
        tfp_printf("           actual redundancy = %d%%\n\r",r);
        for (i=0; i<send_count; ++i) {
                print_frame(tx_frame+i);
        } 
      
        tfp_printf("send frames: \n\r");
    
        t[0]=ReadCoreTimer();        
        for (i=0; i<send_count; ++i) {
                print_frame(tx_frame+i);
                t[i+1]=ReadCoreTimer();
                nrf_snd_pkt(32,tx_frame+i);  
        }
        
        for (i=0; i<send_count; ++i) {
                printf("%08d ns %08d ns\n\r", (t[i+1]-t[0])*50, (t[i+1]-t[i])*50);
        }



        tfp_printf("Destroying frames (simulated erasure)...\n\r");
        destroy_frame(1);
        destroy_frame(3);
        for (i=0; i<send_count; ++i) {
                print_frame(tx_frame+i);
        }

        tfp_printf("Trying to recover missing fragments...\n\r");
        r = recover_received_message();
        if (r) {
                tfp_printf("Success! The message was...\r\n");
                for (i=0; i<r; ++i) {
                        print_frame(tx_frame+i);
                }
        } else {
                tfp_printf("Failure!\r\n");
        }
        return 0;
}


void test(void)
        {
        while(1)
                {
                sendblock();
                delay_ms(20);
                }
         }        
        